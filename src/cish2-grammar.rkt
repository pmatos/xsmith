#lang racket/base

(require
 "grammar-macros.rkt"
 "cish2-properties.rkt"
 "cish2-utils.rkt"
 "scope-graph.rkt"
 "choice.rkt"
 (only-in pprint [empty empty-doc])
 racr
 racket/random
 racket/class
 racket/dict
 racket/list
 (for-syntax
  racket/base
  syntax/parse
  ))


(declare-spec cish2)

(add-to-grammar
 cish2
 [Node #f ([precomment = empty-doc]
           [postcomment = empty-doc])]
 [Program Node ([Declaration *]
                [main : FunctionDefinition])]

 [Declaration Node ([name = (fresh-var-name "x_")])]
 [VariableDeclaration Declaration ([typename = (fresh-var-type)]
                                   Expression)]
 [FunctionDefinition Declaration ([typename = (fresh-var-type)]
                                  [FormalParam *]
                                  Block)]
 [FormalParam Node ([typename = (fresh-var-type)]
                    [name = (fresh-var-name "arg_")])]


 [Statement Node ()]
 [NullStatement Statement ()]
 [Block Statement ([Declaration * = (random 2)]
                   [Statement * = (random 5)])]
 [ExpressionStatement Statement (Expression)]
 [IfStatement Statement ([test : Expression]
                         [then : Statement])]
 [IfElseStatement IfStatement ([else : Statement])]
 [ReturnStatement Statement ()]
 ;[VoidReturnStatement ReturnStatement ()]
 [ValueReturnStatement ReturnStatement (Expression)]

 [LoopStatement Statement ([test : Expression]
                           [body : Statement])]
 [WhileStatement LoopStatement ()]
 [DoWhileStatement LoopStatement ()]
 [ForStatement LoopStatement ([init : Declaration]
                              [update : Expression])]

 [Expression Node ()]

 [AssignmentExpression Expression ([name = "standin-name"]
                                   Expression)]
 [FunctionApplicationExpression Expression ([name = "standin-name"]
                                            [Expression *])]
 [BinaryExpression Expression ([l : Expression]
                               [r : Expression])]
 [AdditionExpression BinaryExpression ()]
 [UnsafeAdditionExpression AdditionExpression ()]
 [SubtractionExpression BinaryExpression ()]
 [UnsafeSubtractionExpression SubtractionExpression ()]
 [MultiplicationExpression BinaryExpression ()]
 [UnsafeMultiplicationExpression MultiplicationExpression ()]
 [DivisionExpression BinaryExpression ()]
 [UnsafeDivisionExpression DivisionExpression ()]

 [IntOnlyBinaryExpression BinaryExpression ()]
 [ModulusExpression IntOnlyBinaryExpression ()]
 [UnsafeModulusExpression ModulusExpression ()]

 [ComparisonExpression BinaryExpression ()]
 [EqualityExpression ComparisonExpression ()]
 [GreaterThanExpression ComparisonExpression ()]
 [LessThanExpression ComparisonExpression ()]
 [LessOrEqualExpression ComparisonExpression ()]
 [GreaterOrEqualExpression ComparisonExpression ()]

 [IfExpression Expression ([test : Expression]
                           [then : Expression]
                           [else : Expression])]
 [LiteralInt Expression (val)]
 [LiteralFloat Expression (val)]
 [VariableReference Expression (name)]

 )

(add-prop cish2
          may-be-generated
          ;; abstract nodes
          [Declaration #f]
          [Statement #f]
          [ReturnStatement #f]
          [LoopStatement #f]
          [Expression #f]
          [BinaryExpression #f]
          [IntOnlyBinaryExpression #f]
          [ComparisonExpression #f]

          ;; Unsafe nodes should be generated by analysis transformations,
          ;; not random choice.
          [UnsafeAdditionExpression #f]
          [UnsafeSubtractionExpression #f]
          [UnsafeMultiplicationExpression #f]
          [UnsafeDivisionExpression #f]
          [UnsafeModulusExpression #f]
          )

(add-prop cish2
          depth-increase-predicate
          [Block (λ (n) (if (member (node-type (parent-node n))
                                    '(IfStatement
                                      IfElseStatement
                                      FunctionDefinition
                                      ForStatement
                                      WhileStatement
                                      DoWhileStatement))
                            (att-value 'ast-depth (parent-node n))
                            (add1 (att-value 'ast-depth (parent-node n)))))]
          ;; some nodes should never increase depth
          [ExpressionStatement (λ(n)#f)]
          [AssignmentExpression (λ(n)#f)]
          [Declaration (λ(n)#f)])

(add-prop cish2
          fresh
          [IfElseStatement (hash
                            'then
                            (make-hole Block)
                            'else
                            (make-hole Block))]
          [AssignmentExpression
           (hash
            'name
            (binding-name (random-ref (send this constrain-type))))]
          [VariableReference
           (hash 'name (binding-name (random-ref
                                      (send this constrain-type))))]
          [FunctionApplicationExpression
           (let ([chosen-func (random-ref (send this constrain-type))])
             (hash 'name
                   (binding-name chosen-func)
                   'Expression
                   (- (length (dict-ref (binding-bound chosen-func)
                                        'type))
                      2)))]
          [VariableDeclaration
           (let ([name (if (equal? (top-ancestor-node current-hole)
                                   (parent-node current-hole))
                           (fresh-var-name "global_")
                           (fresh-var-name "local_"))])
             (hash 'name name
                   'typename (fresh-var-type)))]
          [FunctionDefinition
           (let* ([p (parent-node current-hole)]
                  [main? (and (eq? (node-type p) 'Program)
                              (eq? (ast-child 'main p) current-hole))])
             (hash
              'name
              (if main? "main" (fresh-var-name "func_"))
              'typename
              (if main? int-type (fresh-var-type))
              'FormalParam
              (if main?
                  0
                  ;; This wants to be "make a fresh FormalParam with defaults",
                  ;; which could probably be done by (send fresh (new FormalParamChoice%)),
                  ;; but I wanted the choices to be invisible...  Maybe that's not the
                  ;; best choice.
                  ;; Or I could make a `make-fresh-node` macro like the `make-hole`
                  ;; macro, which could see the choices even though they are otherwise
                  ;; invisible.
                  (create-ast-list
                   (map (λ (x)
                          (create-ast (current-xsmith-grammar)
                                      'FormalParam
                                      (list empty-doc empty-doc
                                            (fresh-var-type)
                                            (fresh-var-name "arg_"))))
                        (make-list (random 5) #f))))))]
          )
